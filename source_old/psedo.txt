function Raytrace(ray, recursive depth) returns Colour {
   colour = background colour

   nearest_t = stupidly big number
   nearest_object = NULL
   
   for each object {
      transform the primary from world space to object space
      solve the ray intersection equation
      find t, the smallest, non-negative real solution of the ray/object intersection

      if t exists {
         if t < nearest_t {
            nearest_t = t
            nearest_object = current object
          }
      }
   }
   
   if nearest_object exists {
      colour = ambient light calculation

      transform the primary ray into object space
      
      calculate the hit point in object space
      calculate the normal vector in object space
      
      if object is mirror reflective {
         reflected_ray = (from intersection point, along reflected ray)
         reflected_colour=Raytrace(reflected_ray, recursive depth -1)
         colour += reflection_coeff * reflected_colour ;
      }

      for each light {

            transform the light position into object space

            calculate lambert, phong values
         
            colour += curr_light_colour * ( lambert + phong  )

      }
   }
   return colour
}
